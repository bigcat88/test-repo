# .github/workflows/triage-reminder.yml
name: Issue triage reminders

on:
  schedule:
    - cron: '0 8 * * *'    # daily at 08:00 UTC
  workflow_dispatch:

permissions:
  issues: write
  contents: read

jobs:
  remind:
    runs-on: ubuntu-latest

    steps:
      - name: Check out repo
        uses: actions/checkout@v3

      - name: Read triage config
        id: cfg
        uses: jbutcher5/read-yaml@1.6
        with:
          file: .github/issue-bot-config.yml
          key-path: '["triage"]'

      # 3Ô∏è‚É£ find all open, un-labelled issues older than first_ping_after_days
      - name: Find stale issues
        id: search
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // parse the triage config (we know it's valid JSON here)
            const cfg = JSON.parse(process.env.CFG || '{}');
            // compute the "cutoff" timestamp
            const since = new Date(
              Date.now() - cfg.first_ping_after_days * 24*3600*1000
            ).toISOString();

            // search for open issues with NO labels, updated before "since"
            const q = [
              `repo:${context.repo.owner}/${context.repo.repo}`,
              `is:issue is:open`,
              `no:label`,
              `updated:<${since}`
            ].join(' ');
            const res = await github.rest.search.issuesAndPullRequests({
              q, per_page: 100
            });

            // pull out just the numbers
            const nums = res.data.items.map(i => i.number);
            core.setOutput("issues", JSON.stringify(nums));

        env:
          # bring the raw JSON string from the read-yaml step into JS
          CFG:    ${{ steps.cfg.outputs.data }}

      - name: Ping & label
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Safely parse both env-vars; fall back to empty array / object
            const issues = JSON.parse(process.env.ISSUES || '[]');
            const cfg    = JSON.parse(process.env.CFG    || '{}');

            for (const num of issues) {
              // fetch the live issue
              const { data: issue } = await github.rest.issues.get({
                ...context.repo, issue_number: num
              });

              // skip if it‚Äôs been updated more recently than repeat_every_days
              const cutoff = new Date(
                Date.now() - cfg.repeat_every_days * 24*3600*1000
              );
              if (new Date(issue.updated_at) > cutoff) continue;

              // figure out which "round" we're on
              const remLabel = issue.labels.find(l => l.name.startsWith('reminder-'));
              const current  = remLabel
                ? parseInt(remLabel.name.split('-')[1], 10)
                : 0;
              const next     = current + 1;

              // build an escalation line once we hit that configured round
              const mention = next >= cfg.escalation_ping
                ? '\n\n' + cfg.escalation_mentions.join(' ')
                : '';

              // post the friendly reminder
              await github.rest.issues.createComment({
                ...context.repo,
                issue_number: num,
                body: `üîî Friendly reminder ‚Äì please triage this issue.${mention}`
              });

              // remove the old reminder label, if any
              if (remLabel) {
                await github.rest.issues.removeLabel({
                  ...context.repo,
                  issue_number: num,
                  name: remLabel.name
                }).catch(() => {});
              }

              // add the new one
              await github.rest.issues.addLabels({
                ...context.repo,
                issue_number: num,
                labels: [`reminder-${next}`]
              });
            }
        env:
          ISSUES: ${{ steps.search.outputs.issues }}
          CFG:    ${{ steps.cfg.outputs.data }}
